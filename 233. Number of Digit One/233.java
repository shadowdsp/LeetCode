class Solution {
    public int countDigitOne(int n) {
        int ans = 0;
        for (long i = 1; i <= n; i *= 10) {
            /*
            假设i=1000.
            1. 当n=452321的时候，up=452，dw=321，对于up%10这一位的1作出的贡献，有(45+1)*1000次，45是因为取up/10的时候即0~44每一次会在up%10这一位出现1，+1是因为自己本身超过了1，可以计算多一次。
            2. 当n=451321的时候，up=451，dw=321，对于up%10这一位的1作出的贡献，有(45)*1000+dw+1次，45的原因同上，+dw+1次是因为up%10这一位是1，所以会多贡献0-dw即dw+1次。
            3. 当n=450321的时候，up=450，dw=321，这时候只需要算45*1000即可，没有多余的贡献。
            */
            long up = n / i; // 每次都计算up的第一位贡献了多少次
            long dw = n % i;
            if (up % 10 > 1) { // 如果那一位大于1，那么就会贡献(up/10+1)*i个1
                ans += (up / 10 + 1) * i;
            } else if (up % 10 == 1) { // 如果等于1，那么就会贡献(up/10)*i+dw+1个1
                ans += (up / 10) * i + dw + 1;
            } else { // 如果等于0，那么就会贡献(up/10)*i个1
                ans += (up / 10) * i;
            }
        }
        return ans;
    }
}